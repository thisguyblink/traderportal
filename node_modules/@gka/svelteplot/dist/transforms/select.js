import { groupFacetsAndZ } from '../helpers/group.js';
import { resolveChannel } from '../helpers/resolve.js';
// let o: SelectOptions = { x: 'min'};
export function select({ data, ...channels }, options) {
    const newData = [];
    groupFacetsAndZ(data, channels, (items) => {
        if (typeof options === 'string') {
            if (options !== 'first' && options !== 'last')
                throw new Error('unknown sort option: ' + options);
            newData.push(options === 'first' ? items[0] : items.at(-1));
        }
        else {
            const sortOptions = Object.entries(options);
            if (!sortOptions.length)
                throw new Error('must provide the channel to sort by');
            if (sortOptions.length > 1)
                throw new Error('cannot sort by more than one channel');
            if (sortOptions[0][1] !== 'min' && sortOptions[0][1] !== 'max')
                throw new Error('unknown sort option: ' + sortOptions[0][1]);
            const selected = items
                .map((item) => ({
                ...item,
                __sortby: resolveChannel(sortOptions[0][0], item, channels)
            }))
                .sort((a, b) => (a.__sortby > b.__sortby ? 1 : a.__sortby < b.__sortby ? -1 : 0))
                .at(sortOptions[0][1] === 'min' ? 0 : -1);
            newData.push(selected);
        }
    });
    return { data: newData, ...channels };
}
/**
 * Keeps only the first item of each group
 */
export function selectFirst(args) {
    return select(args, 'first');
}
/**
 * Keeps only the last item of each group
 */
export function selectLast(args) {
    return select(args, 'last');
}
export function selectMinX(args) {
    return select(args, { x: 'min' });
}
export function selectMaxX(args) {
    return select(args, { x: 'max' });
}
export function selectMinY(args) {
    return select(args, { y: 'min' });
}
export function selectMaxY(args) {
    return select(args, { y: 'max' });
}

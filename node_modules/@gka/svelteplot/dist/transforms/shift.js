import { resolveChannel } from '../helpers/resolve.js';
import { maybeTimeInterval } from '../helpers/time.js';
export function shiftX({ data, ...channels }, shiftBy) {
    if (typeof shiftBy === 'number' || typeof shiftBy === 'string') {
        shiftBy = { x: shiftBy };
    }
    if (shiftBy) {
        if (shiftBy)
            return shiftChannels('x', shiftBy, { data, ...channels });
    }
    return { data, ...channels };
}
export function shiftY({ data, ...channels }, shiftBy) {
    if (typeof shiftBy === 'number' || typeof shiftBy === 'string') {
        shiftBy = { y: shiftBy };
    }
    if (shiftBy)
        return shiftChannels('y', shiftBy, { data, ...channels });
    return { data, ...channels };
}
function shiftChannels(shiftDim, shiftBy, { data, ...channels }) {
    return {
        data: data.map((d) => {
            const newRow = { ...d };
            for (const [channel, shift] of Object.entries(shiftBy)) {
                const shiftFrom = (channels[channel] != null ? channel : shiftDim);
                if (typeof shift === 'number') {
                    newRow[`__shift_${channel}`] =
                        resolveChannel(shiftFrom, d, channels) + shift;
                }
                else if (typeof shift === 'string') {
                    const [, sign, value, unit] = shift.match(/^([+-])?(\d+)? ?([a-z]+)$/);
                    const step = (sign === '-' ? -1 : 1) * (value || 1);
                    const interval = maybeTimeInterval(unit);
                    if (!interval)
                        throw new Error(`Invalid shift interval: ${shift}`);
                    newRow[`__shift_${channel}`] = interval.offset(resolveChannel(shiftFrom, d, channels), step);
                }
            }
            return newRow;
        }),
        ...channels,
        ...Object.fromEntries(Object.keys(shiftBy).map((key) => [key, `__shift_${key}`]))
    };
}

import { resolveChannel } from '../helpers/resolve.js';
export function bollingerX(args, options = {}) {
    return bollingerDim('x', args, options);
}
export function bollingerY(args, options = {}) {
    return bollingerDim('y', args, options);
}
export function bollingerDim(dim, { data, ...channels }, options = {}) {
    const { n = 20, k = 2 } = options;
    const bands = bollinger(data.map((datum) => resolveChannel(dim, datum, channels)), n, [-k, 0, k]);
    const otherDim = dim === 'x' ? 'y' : 'x';
    return {
        data: data.map((datum, i) => ({
            __x: resolveChannel(otherDim, datum, channels),
            __lo: bands[0][i],
            __avg: bands[1][i],
            __hi: bands[2][i]
        })),
        ...channels,
        [otherDim]: '__x',
        [dim]: '__avg',
        [`${otherDim}1`]: '__x',
        [`${dim}1`]: '__lo',
        [`${dim}2`]: '__hi'
    };
}
/**
 * taken from https://observablehq.com/@d3/bollinger-bands/
 */
function bollinger(values, N, K) {
    let i = 0;
    let sum = 0;
    let sumSquared = 0;
    // initialize bands
    const bands = K.map(() => new Float64Array(values.length).fill(NaN));
    // compute sum and square of sums
    for (let n = Math.min(N - 1, values.length); i < n; ++i) {
        const value = values[i];
        (sum += value), (sumSquared += value ** 2);
    }
    for (let n = values.length, m = bands.length; i < n; ++i) {
        const value = values[i];
        (sum += value), (sumSquared += value ** 2);
        const mean = sum / N;
        const deviation = Math.sqrt((sumSquared - sum ** 2 / N) / (N - 1));
        for (let j = 0; j < K.length; ++j) {
            bands[j][i] = mean + deviation * K[j];
        }
        const value0 = values[i - N + 1];
        (sum -= value0), (sumSquared -= value0 ** 2);
    }
    return bands;
}

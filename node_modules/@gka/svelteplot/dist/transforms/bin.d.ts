import type { DataRecord, RawValue } from '../types.js';
import type { TransformArg } from '../types.js';
import { type ThresholdCountGenerator } from 'd3-array';
import { Reducer, type ReducerName } from '../helpers/reduce.js';
type NamedThresholdsGenerator = 'auto' | 'scott' | 'sturges' | 'freedman-diaconis';
type BinBaseOptions = {
    domain?: [number, number];
    thresholds?: NamedThresholdsGenerator | number | number[] | ThresholdCountGenerator;
    interval?: number | string;
    cumulative?: false | 1 | -1;
    reverse?: boolean;
};
type ReducerOption = ReducerName | ((group: DataRecord[]) => RawValue);
type AdditionalOutputChannels = Partial<{
    fill: ReducerOption;
    stroke: ReducerOption;
    r: ReducerOption;
    opacity: ReducerOption;
    fillOpacity: ReducerOption;
    strokeOpacity: ReducerOption;
}>;
export type BinXOptions = BinBaseOptions & AdditionalOutputChannels & Partial<{
    y: typeof Reducer;
    y1: typeof Reducer;
    y2: typeof Reducer;
}>;
export type BinYOptions = BinBaseOptions & AdditionalOutputChannels & Partial<{
    x: typeof Reducer;
    x1: typeof Reducer;
    x2: typeof Reducer;
}>;
type BinOptions = BinBaseOptions & AdditionalOutputChannels;
/**
 * Bins on x. Also groups on y and the first channel of z, fill, or stroke, if any.
 *
 * @param param0
 * @param options
 */
export declare function binX<T>({ data, ...channels }: TransformArg<T, DataRecord>, options?: BinXOptions): TransformArg<T, DataRecord>;
/**
 * Bins on y. Also groups on y and the first channel of z, fill, or stroke, if any.
 *
 * @param param0
 * @param options
 */
export declare function binY<T>({ data, ...channels }: TransformArg<T, DataRecord>, options?: BinYOptions): TransformArg<T, DataRecord>;
/**
 * for binning in x and y dimension simulatenously
 */
export declare function bin<T>({ data, ...channels }: TransformArg<T, DataRecord>, options?: BinOptions): TransformArg<T, DataRecord>;
export {};

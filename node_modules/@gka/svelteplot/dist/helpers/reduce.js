import { min, max, mode, sum, mean, median, variance, deviation, quantile, range } from 'd3-array';
import { resolveChannel } from './resolve.js';
import { POSITION_CHANNELS } from './index.js';
const niceReduceNames = {
    count: 'Frequency',
    deviation: 'Standard Deviation',
    mean: 'Average'
};
const StaticReducer = {
    count: (d) => Array.from(d).length,
    min,
    max,
    mode,
    sum,
    mean,
    median,
    identity: (d) => d,
    variance,
    deviation,
    first: (d) => d[0],
    last: (d) => d.at(-1),
    difference: (d) => d.at(-1) - d[0],
    ratio: (d) => d.at(-1) / d[0]
    // TODO: proportion
    // TODO: proportion-facet
    // TODO: min-index
    // TODO: max-index
};
// use proxy to allow for percentile reducers
export const Reducer = new Proxy(StaticReducer, {
    get(target, prop) {
        if (String(prop).charAt(0) === 'p' && String(prop).length === 3) {
            const p = +String(prop).slice(1) / 100;
            return percentile(p);
        }
        return Reflect.get(target, prop);
    },
    has(target, prop) {
        if (String(prop).charAt(0) === 'p' && String(prop).length === 3) {
            return true;
        }
        return Reflect.has(target, prop);
    }
});
function percentile(p) {
    return (I, f) => quantile(I, p, f);
}
function isReducerName(r) {
    return typeof r === 'string' && r in Reducer;
}
export function mayberReducer(r) {
    if (typeof r === 'function')
        return r;
    if (typeof r === 'string' && isReducerName(r)) {
        return Reducer[r];
    }
    throw new Error('unknown reducer ' + r);
}
export function reduceOutputs(newDatum, data, options, outputs, channels, newChannels) {
    for (const k of outputs) {
        if (options[k] != null) {
            const values = channels[k] == null ? data : data.map((d) => resolveChannel(k, d, channels));
            const reducer = mayberReducer(options[k]);
            newDatum[`__${k}`] = reducer(values);
            newChannels[k] = `__${k}`;
            if (typeof options[k] === 'string') {
                const reducerName = niceReduceNames[options[k]] ??
                    `${String(options[k]).charAt(0).toUpperCase()}${String(options[k]).slice(1)}`;
                // we have a named reducer like 'count', so let's try to preserve the
                // source channel mapping for axis labels
                if (POSITION_CHANNELS.has(k)) {
                    if (typeof channels[k] === 'string') {
                        // the named reducer is applied to a column name, so we can use a combination
                        // of both as axis labels, e.g. MEAN(weight)
                        // eslint-disable-next-line no-irregular-whitespace
                        newChannels[`__${k}_origField`] = `${reducerName} ( ${channels[k]} )`;
                    }
                    else {
                        newChannels[`__${k}_origField`] = reducerName;
                    }
                }
            }
        }
    }
}

import { resolveProp } from './resolve.js';
import { isDate } from './typeChecks';
/**
 * Returns first argument that is not null or undefined
 */
export function coalesce(...args) {
    for (const arg of args) {
        if (arg !== null && arg !== undefined) {
            return arg;
        }
    }
    return null; // Return null if all arguments are null or undefined
}
export function testFilter(datum, options) {
    return options.filter == null || resolveProp(options.filter, datum);
}
export function randomId() {
    return Math.ceil(1e9 + Math.random() * 1e9).toString(36);
}
export function isSnippet(value) {
    return typeof value === 'function' && value.length === 1;
}
export function isValid(value) {
    return value !== null && value !== undefined && !Number.isNaN(value);
}
export function maybeData(data) {
    // if (data.type === 'FeatureCollection') return data.features;
    return data;
}
export function isObject(option) {
    // doesn't work with Proxies
    return (typeof option === 'object' && !isDate(option) && !Array.isArray(option) && option !== null);
}
export function maybeNumber(value) {
    return value != null ? +value : null;
}
export const constant = (x) => () => x;
export const POSITION_CHANNELS = new Set(['x', 'x1', 'x2', 'y', 'y1', 'y2']);
export function parseInset(inset, width) {
    if (typeof inset === 'number') {
        return inset;
    }
    if (inset.endsWith('%')) {
        return (width * +inset.slice(0, -1)) / 100;
    }
    return +inset;
}
export function omit(obj, ...keys) {
    return Object.fromEntries(Object.entries(obj).filter(([key]) => !keys.includes(key)));
}
export function identity(x) {
    return x;
}
